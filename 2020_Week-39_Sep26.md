# ARTS Week 39

## Algorithm

题目本身不复杂，可以用回溯法解决。

重点是题目要求是 ```root to leaf```，只有终端的节点才是叶子节点，这点基础概念需要留意。

```python
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:

        if not root:
            return []

        ret = []
        stack = []

        def helper(current_root, current_sum):
            if not current_root:
                return
            
            stack.append(current_root.val)
            
            if current_root.val == current_sum and not current_root.left and not current_root.right:
                ret.append(stack.copy())
            
            helper(current_root.left, current_sum-current_root.val)
            helper(current_root.right, current_sum-current_root.val)

            stack.pop(-1)
        
        helper(root, sum)
        
        return ret
```

## Review

[联邦学习技术突破医疗隐私围城 - 知乎](https://zhuanlan.zhihu.com/p/257812539)

国内医院的医疗数据量虽然非常可观，但是涉及到医疗隐私、安全以及图像数据量庞大等问题，想要直接采集多家医院的医疗数据用于训练其实并不现实。因此，联邦学习“以数据不出库为前提进行模型训练”的愿景，在医疗领域有非常广阔的应用前景。

联邦学习按数据的分布特点可以分为以下几类：

- 横向联邦学习：指两个数据集特征重叠多、案例重叠少时，通过联邦学习提高特征提取能力的场景。
- 纵向联邦学习：指两个数据集案例重叠多、特征重叠少，通过联邦学习拓宽模型可以识别的特征数量的场景。
- 联邦迁移学习：指两个数据集案例和特征重叠度较小，通过联邦学习解决单边数据规模小的问题。

在医疗领域，NVIDIA Clara 框架提供了一套联邦学习的实践。

## Tips

在 ```git clone``` 和 ```git fetch``` 命令中，可以通过添加 ```--depth 1``` 参数限制拉取的 commit 数，从而加快拉取的速度，而且在拉取大型项目的时候可以减少空间占用。

## Share

### 云原生技术入门 - 介绍

最近一段时间一直在做一些技术框架上的调研，机缘巧合接触到了云原生的概念，突然打开了新世纪的大门。相信以“云”为核心的软件研发思想，将会成为接下来技术人员的标配。

阿里云推出的[云原生公开课](https://edu.aliyun.com/course/1651)是一门非常好的入门课程，近期打算围绕这门课程写一些入门文章，总结一些核心的概念与操作。

[维基百科](https://en.wikipedia.org/wiki/Cloud_native_computing)上对云原生的定义我觉得非常的精准：利用云计算技术，在公有云、私有云或混合云等现代、动态的环境中，构建和运行可扩展（Scalable）应用的软件开发技术。

在合理运用基于容器的开发模式以前，软件开发过程中经常会因为数据、软件环境、设施、接口等因素带来不可预料的问题。而在应用容器设计模式之后，容器在分布式系统上的编排以及容器间的通信又给系统设计带来了新的问题。

以 Kubernetes 为核心的云原生技术，就给出了一套全新的软件开发、发布和运维的模式。

云原生思想有两个理论基础：

- 不可变基础设施：通过容器镜像和版本管理，保证基础设施的一致性。
- 云应用编排理论：以容器为核心的设计模式。

其中，不可变基础设施的核心诉求，就是从传统的应用基础设施到对“云”友好的应用基础设施的转变。

传统的服务器运维模式，由运维通过 SSH 连接到服务器上手动升降级软件包、逐个服务器调整配置文件的模式，每一个基础设施就像“独一无二的宠物”一样。一旦某一台服务器突然挂掉，对于在这台服务器上开发的项目将是灭顶之灾。即便采用了一些自动化运维技术并进行了充分的备份，恢复这个基础设施也是非常痛苦的过程。以 Python 环境配置为例，很有可能去年的安装脚本，因为依赖链条上的某一个库没有指定版本，需要很痛苦地排查核对，确定安装顺序，才能正常跑起来。

而对“云”友好的应用基础设施，环境通过构建容器镜像来统一，部署完成后即不可被修改，而容器镜像本身则有另外的更新机制。这样基础设施就成为“可以替代的牲口”，可以随时替换。

而以容器为核心进行开发时，就需要相应的设计模式和配套设施的支持。云原生技术就是 Cloud Native Computing Foundation 给出的一套软件工具和设计模式。
